import { transformVariableName } from "../src/utils";
import * as esprima from "esprima";
import * as estraverse from "estraverse";
import * as fs from "fs";
import * as http from "http";
import * as https from "https";

const scriptUrl =
  "https://raw.githubusercontent.com/Purfview/IMDb-Scout-Mod/master/IMDb_Scout_Mod.user.js";
let code: string = await new Promise((resolve, reject) => {
  https
    .get(scriptUrl, (response: http.IncomingMessage) => {
      if (response.statusCode !== 200) {
        reject(`Received status code: ${response.statusCode}`);
      }
      let data = "";
      response.on("data", (chunk: any) => (data += chunk));
      response.on("end", () => resolve(data));
    })
    .on("error", (err: Error) => {
      reject(err);
    });
});
const ast = esprima.parseScript(code, { tolerant: true });

let privateSitesConfig: PrivateSiteConfig[] = [];

estraverse.traverse(ast, {
  enter: function (node) {
    if (node.type === "VariableDeclaration") {
      for (let declaration of node.declarations) {
        if (!("name" in declaration.id)) {
          continue;
        }
        if (!declaration.init) {
          continue;
        }
        if (
          declaration.id.name === "private_sites" &&
          declaration.init.type === "ArrayExpression"
        ) {
          privateSitesConfig = declaration.init.elements.map((element: any) => {
            if (element.type === "Literal") {
              return element.value;
            } else if (element.type === "ObjectExpression") {
              let obj: PrivateSiteConfig = {
                name: "",
                searchUrl: "",
              };
              for (let property of element.properties) {
                // Assuming property keys are of type 'Identifier'
                let key = property.key.value;
                let value = undefined;
                if (property.value.type === "Literal" && property.value.regex) {
                  value = new RegExp(
                    property.value.regex.pattern,
                    property.value.regex.flags
                  );
                } else {
                  value = property.value.value;
                }
                obj[key] = value;
              }
              return obj;
            }
          });
          return;
        }
      }
    }
  },
});

if (privateSitesConfig) {
  const excludeKeys = ["icon"];

  let output = `// FILE AUTOGENERATED\nexport type PrivateTracker = {
  name: string;
  TV?: boolean;
  searchUrl: string;
  mPOST?: string;
  spaceEncode?: string;
  [key: string]: boolean | string | RegExp | undefined | number;
};\n\n`;

  for (const item of privateSitesConfig) {
    const itemName = item.name;
    let itemProps = "";

    for (const key in item) {
      if (!excludeKeys.includes(key)) {
        if (item[key] instanceof RegExp) {
          itemProps += `  ${key}: ${item[key]},\n`;
        } else if (
          typeof item[key] === "boolean" ||
          typeof item[key] === "number"
        ) {
          itemProps += `  ${key}: ${item[key]},\n`;
        } else {
          itemProps += `  ${key}: '${item[key]}',\n`;
        }
      }
    }

    let name = transformVariableName(itemName);
    if (item.TV) {
      name += "_TV";
    }
    output += `export const ${name}: PrivateTracker = {\n${itemProps}};\n\n`;
  }

  fs.writeFileSync("src/trackers/index.ts", output);
} else {
  console.log("Could not parse private sites config.");
}

type PrivateSiteConfig = {
  name: string;
  TV?: boolean;
  searchUrl: string;
  mPOST?: string;
  [key: string]: boolean | string | RegExp | undefined | number;
};
